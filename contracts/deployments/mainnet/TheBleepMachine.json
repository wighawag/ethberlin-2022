{
  "address": "0x99174dBF4Ff14F2F0148fCFd551b0DfC742A421F",
  "abi": [
    {
      "inputs": [],
      "name": "MusicByteCodeTooLarge",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MusicContractCreationFailure",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MusicExecutionFailure",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "musicBytecode",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "start",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "WAV",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "musicBytecode",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "start",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "generate",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "listenTo",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x98ec3cfd6a828f1f1efb1d4db5a15d7dbbfe1748ec03aae7f3fad147390902d4",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x2aE1389b686404959Eb61205c78e1103b85F157f",
    "contractAddress": null,
    "transactionIndex": 140,
    "gasUsed": "390429",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf4e6c357db4fb031c3ac128771cf3df456025b99cce39a716d771629237cbdca",
    "transactionHash": "0x98ec3cfd6a828f1f1efb1d4db5a15d7dbbfe1748ec03aae7f3fad147390902d4",
    "logs": [],
    "blockNumber": 15640602,
    "cumulativeGasUsed": "12777456",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "a86187af63e1272cc104846ff4fd70c2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MusicByteCodeTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MusicContractCreationFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MusicExecutionFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"musicBytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"WAV\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"musicBytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"generate\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"listenTo\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"WAV(bytes,uint256,uint256)\":{\"params\":{\"length\":\"the number of samples to generate.\",\"musicBytecode\":\"the EVM bytecode that the Bleep Machine will execute in a loop.\",\"start\":\"sample offset at which the music starts.\"},\"returns\":{\"_0\":\"WAV file (8 bits, 8000Hz, mono).\"}},\"generate(bytes,uint256,uint256)\":{\"params\":{\"length\":\"the number of samples to generate.\",\"musicBytecode\":\"the EVM bytecode that the Bleep Machine will execute in a loop.\",\"start\":\"sample offset at which the music starts.\"},\"returns\":{\"_0\":\"8 bits samples buffer.\"}},\"listenTo(address)\":{\"params\":{\"addr\":\"address of any contract. Most will generate noises.\"},\"returns\":{\"_0\":\"WAV file (8 bits, 8000Hz, mono).\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"WAV(bytes,uint256,uint256)\":{\"notice\":\"Generates a WAV file (8 bits, 8000Hz, mono) by executing the EVM bytecode provided (`musicBytecode`). The time offset is the only element on the stack at each loop iteration. Such offset starts at `start` and is increased by one for each iteration. The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration. The loop is executed `length` times to generate `length` samples which compose the music generated.\"},\"generate(bytes,uint256,uint256)\":{\"notice\":\"Generates raw 8 bits samples by executing the EVM bytecode provided (`musicBytecode`). The time offset is the only element on the stack at each loop iteration. Such offset starts at `start` and is increased by one for each iteration. The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration. The loop is executed `length` times to generate `length` samples which compose the music generated.\"},\"listenTo(address)\":{\"notice\":\"Generates a WAV file (8 bits, 8000Hz, mono) from contract's code at a specific address.\"},\"name()\":{\"notice\":\"return the name of the contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/TheBleepMachine.sol\":\"TheBleepMachine\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"src/TheBleepMachine.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\n// _/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\__/\\\\/\\\\________________________/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____________________________________________/\\\\/\\\\______/\\\\/\\\\__________________________/\\\\/\\\\________/\\\\/\\\\___________________________\\n// _____/\\\\/\\\\______/\\\\/\\\\__________/\\\\/\\\\/\\\\________/\\\\/\\\\____/\\\\/\\\\__/\\\\/\\\\______/\\\\/\\\\/\\\\______/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\________/\\\\/\\\\/\\\\__/\\\\/\\\\/\\\\__/\\\\/\\\\/\\\\________/\\\\/\\\\/\\\\/\\\\__/\\\\/\\\\________________/\\\\/\\\\/\\\\/\\\\______/\\\\/\\\\/\\\\___\\n// _____/\\\\/\\\\______/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\/\\\\______/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\/\\\\__/\\\\/\\\\/\\\\/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\______/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\/\\\\______/\\\\/\\\\____/\\\\/\\\\________/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\/\\\\/\\\\/\\\\_\\n// _____/\\\\/\\\\______/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\____________/\\\\/\\\\____/\\\\/\\\\__/\\\\/\\\\____/\\\\/\\\\________/\\\\/\\\\________/\\\\/\\\\/\\\\/\\\\________/\\\\/\\\\__/\\\\__/\\\\/\\\\__/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\________/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\____/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\_______\\n// _____/\\\\/\\\\______/\\\\/\\\\__/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\______/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\__/\\\\/\\\\____________/\\\\/\\\\______/\\\\/\\\\__/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\/\\\\__/\\\\/\\\\__/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\_\\n// _________________________________________________________________________________________/\\\\/\\\\_______________________________________________________________________________________________\\n\\n// The Bleep Machine Generates Music From Executing Ethereum Bytecode.\\n\\n// It is an implementation of Bytebeat on the EVM.\\n//\\n// Try the following:\\n//\\n// cast call --rpc-url https://rpc.bleeps.art machine.bleeps.eth \\\"WAV(bytes,uint256,uint256)(bytes)\\\" 0x808060081c9160091c600e1661ca98901c600f160217  0 100000 | xxd -r -p | aplay\\n//\\n// Note: this requires cast (see: https://github.com/foundry-rs) + aplay + xxd + a working ethereum rpc node (here: https://rpc.bleeps.art).\\n//\\n// This will execute the following formula: `t*(0xCA98>>(t>>9&14)&15)|t>>8` (taken from http://viznut.fi/texts-en/bytebeat_exploring_space.pdf)\\n//\\n// It will be executed 100,000 times with t starting at 0 and increasing by one on each iteration.\\n//\\n// This will produce a WAV file of 100,000 samples (8 bits, mono) at 8000 hz (or 12.5 seconds).\\n\\n// Copyright (C) 2022 Ronan Sandford\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.16;\\n\\nerror MusicByteCodeTooLarge();\\nerror MusicContractCreationFailure();\\nerror MusicExecutionFailure();\\n\\ncontract TheBleepMachine {\\n\\t/// @notice return the name of the contract\\n\\tfunction name() external pure returns (string memory) {\\n\\t\\treturn \\\"The Bleep Machine\\\";\\n\\t}\\n\\n\\t/// @notice Generates a WAV file (8 bits, 8000Hz, mono) by executing the EVM bytecode provided (`musicBytecode`).\\n\\t/// The time offset is the only element on the stack at each loop iteration.\\n\\t/// Such offset starts at `start` and is increased by one for each iteration.\\n\\t/// The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration.\\n\\t/// The loop is executed `length` times to generate `length` samples which compose the music generated.\\n\\t/// @param musicBytecode the EVM bytecode that the Bleep Machine will execute in a loop.\\n\\t/// @param start sample offset at which the music starts.\\n\\t/// @param length the number of samples to generate.\\n\\t/// @return WAV file (8 bits, 8000Hz, mono).\\n\\tfunction WAV(\\n\\t\\tbytes memory musicBytecode,\\n\\t\\tuint256 start,\\n\\t\\tuint256 length\\n\\t) external returns (bytes memory) {\\n\\t\\t// Create empty wav file of size `length` with proper header.\\n\\t\\tbytes memory wavFile = _wavFile(length);\\n\\t\\t// Generate the samples in it at offset 44 (header size)\\n\\t\\t_generateAndwrite(musicBytecode, start, length, wavFile, 44);\\n\\t\\treturn wavFile;\\n\\t}\\n\\n\\t/// @notice Generates raw 8 bits samples by executing the EVM bytecode provided (`musicBytecode`).\\n\\t/// The time offset is the only element on the stack at each loop iteration.\\n\\t/// Such offset starts at `start` and is increased by one for each iteration.\\n\\t/// The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration.\\n\\t/// The loop is executed `length` times to generate `length` samples which compose the music generated.\\n\\t/// @param musicBytecode the EVM bytecode that the Bleep Machine will execute in a loop.\\n\\t/// @param start sample offset at which the music starts.\\n\\t/// @param length the number of samples to generate.\\n\\t/// @return 8 bits samples buffer.\\n\\tfunction generate(\\n\\t\\tbytes memory musicBytecode,\\n\\t\\tuint256 start,\\n\\t\\tuint256 length\\n\\t) external returns (bytes memory) {\\n\\t\\t// Create empty bytes array of exact length\\n\\t\\tbytes memory samples = new bytes(length);\\n\\t\\t// Generate the samples in it\\n\\t\\t_generateAndwrite(musicBytecode, start, length, samples, 0);\\n\\t\\treturn samples;\\n\\t}\\n\\n\\t/// @notice Generates a WAV file (8 bits, 8000Hz, mono) from contract's code at a specific address.\\n\\t/// @param addr address of any contract. Most will generate noises.\\n\\t/// @return WAV file (8 bits, 8000Hz, mono).\\n\\tfunction listenTo(address addr) external view returns (bytes memory) {\\n\\t\\tuint256 size;\\n\\t\\tassembly {\\n\\t\\t\\tsize := extcodesize(addr)\\n\\t\\t}\\n\\t\\tbytes memory buffer = _wavFile(size);\\n\\t\\tassembly {\\n\\t\\t\\t// copy code in that buffer at pos 76 = 44 (wav header size) + 32 (where bytes size is stored)\\n\\t\\t\\textcodecopy(addr, add(buffer, 76), 0, size)\\n\\t\\t}\\n\\t\\treturn buffer;\\n\\t}\\n\\n\\t// ----------------------------------------------------------------------------------------------------------------\\n\\t// INTERNAL\\n\\t// ----------------------------------------------------------------------------------------------------------------\\n\\n\\t/// @dev generate sample data by executing the EVM bytecode provided (`musicBytecode`) and write it in buffer.\\n\\t/// It generates the data in the provided buffer (assumed to have the correct length already, see _wavFile)\\n\\t/// @param musicBytecode the EVM bytecode the Bleep Machine will execute in a loop.\\n\\t/// @param start sample offset at which the music starts.\\n\\t/// @param length the number of samples to generate.\\n\\t/// @param buffer buffer to write to\\n\\t/// @param offset offset to start writing to\\n\\tfunction _generateAndwrite(\\n\\t\\tbytes memory musicBytecode,\\n\\t\\tuint256 start,\\n\\t\\tuint256 length,\\n\\t\\tbytes memory buffer,\\n\\t\\tuint256 offset\\n\\t) internal {\\n\\t\\t// We create the contract from the music bytecode.\\n\\t\\taddress executor = _create(musicBytecode);\\n\\n\\t\\tbool success;\\n\\t\\tassembly {\\n\\t\\t\\t// We ask solidity for the pointer to free memory (not yet used)\\n\\t\\t\\tlet argsPointer := mload(0x40)\\n\\t\\t\\t// We then store at that position the arguments <start><length> (in 32 bytes, 128 bits each)\\n\\t\\t\\tmstore(argsPointer, or(shr(128, shl(128, start)), shl(128, length)))\\n\\t\\t\\t// We then make the call\\n\\t\\t\\t// and store the result in the existing buffer at pos = offset + 32\\n\\t\\t\\t// (the first 32 bytes store the length of the bytes array)\\n\\t\\t\\tsuccess := staticcall(gas(), executor, argsPointer, 32, add(buffer, add(offset, 32)), length)\\n\\t\\t}\\n\\n\\t\\t// If there is any error, we revert.\\n\\t\\tif (!success) {\\n\\t\\t\\trevert MusicExecutionFailure();\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Creates a new contract that generate the music from a given start offset and length.\\n\\t/// @param musicBytecode the EVM bytecode the Bleep Machine will execute in a loop.\\n\\t/// @return executor address of the contract that will generate samples when executed.\\n\\tfunction _create(bytes memory musicBytecode) internal returns (address executor) {\\n\\t\\t// This code generates a contract creation-code that loops over the provided `musicBytecode`.\\n\\n\\t\\t// 61006d600081600b8239f3 => simply copy the code after it.\\n\\t\\t// Note that 006d will is overwritten below with the new length\\n\\n\\t\\t// 6000358060801b60801c806000529060801c6020525b => prepare the data\\n\\t\\t// In particular it parses the call-data to extract the start and length parameters (Stored in 128bit each).\\n\\t\\t// It then ensures that the starting time is on top of the stack before the loop starts.\\n\\t\\t// The last `5b` is a JUMPDEST that will be jumped to at each iteration.\\n\\n\\t\\t// 6040519060ff16816060015360010180604052600051810190602051116015576020516060f3\\n\\t\\t// => Performs the loop and when it ends (start + time >= length), it copy the generated buffer in return data.\\n\\n\\t\\tbytes memory executorCreation = bytes.concat(\\n\\t\\t\\thex\\\"61006d600081600b8239f36000358060801b60801c806000529060801c6020525b\\\",\\n\\t\\t\\tmusicBytecode,\\n\\t\\t\\thex\\\"6040519060ff16816060015360010180604052600051810190602051116015576020516060f3\\\"\\n\\t\\t);\\n\\t\\tuint256 len = musicBytecode.length;\\n\\n\\t\\t// We make sure the generated code length can be encoded in the PUSH2.\\n\\t\\tuint256 codeLen;\\n\\t\\tunchecked {\\n\\t\\t\\tcodeLen = 0x3C + len;\\n\\t\\t}\\n\\t\\tif (codeLen > 0xFFFF) {\\n\\t\\t\\trevert MusicByteCodeTooLarge();\\n\\t\\t}\\n\\n\\t\\t// We store the generated creationCode length so that the creationCode work with its new length.\\n\\t\\tassembly {\\n\\t\\t\\tmstore8(add(executorCreation, 33), shr(8, codeLen))\\n\\t\\t\\tmstore8(add(executorCreation, 34), and(codeLen, 0xFF))\\n\\t\\t}\\n\\n\\t\\t// We create the contract.\\n\\t\\tassembly {\\n\\t\\t\\texecutor := create(0, add(executorCreation, 32), mload(executorCreation))\\n\\t\\t}\\n\\n\\t\\t// If there is any error, we revert.\\n\\t\\tif (executor == address(0)) {\\n\\t\\t\\trevert MusicContractCreationFailure();\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev generate an empty WAV file of length `length`\\n\\t/// @param length the number of samples in the WAV file.\\n\\t/// @return wavFile : zeroed out WAV file with correct headers data.\\n\\tfunction _wavFile(uint256 length) internal pure returns (bytes memory wavFile) {\\n\\t\\tunchecked {\\n\\t\\t\\twavFile = new bytes(length + 44); // 44 is the header size\\n\\t\\t}\\n\\n\\t\\tassembly {\\n\\t\\t\\t// WAV file header, 8 bits, 8000Hz, mono, empty length.\\n\\t\\t\\tmstore(add(wavFile, 32), 0x524946460000000057415645666d74201000000001000100401f0000401f0000)\\n\\t\\t\\tmstore(add(wavFile, 64), 0x0100080064617461000000000000000000000000000000000000000000000000)\\n\\n\\t\\t\\t// Top header length is length of data + 36 bytes.\\n\\t\\t\\t// More precisely: (4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)).\\n\\t\\t\\t// Where SubChunk1Size is 16 (for PCM) and SubChunk2Size is the length of the data.\\n\\t\\t\\tlet t := add(length, 36)\\n\\t\\t\\t// We write that length info in the top header (in little-endian).\\n\\t\\t\\tmstore8(add(wavFile, 36), and(t, 0xFF))\\n\\t\\t\\tmstore8(add(wavFile, 37), and(shr(8, t), 0xFF))\\n\\t\\t\\tmstore8(add(wavFile, 38), and(shr(16, t), 0xFF))\\n\\t\\t\\t// We also write the exact data length just before the data stream as per WAV file format spec (in little-endian).\\n\\t\\t\\tmstore8(add(wavFile, 72), and(length, 0xFF))\\n\\t\\t\\tmstore8(add(wavFile, 73), and(shr(8, length), 0xFF))\\n\\t\\t\\tmstore8(add(wavFile, 74), and(shr(16, length), 0xFF))\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x18d362ef2d24e4811f948069bada0681c205d943b21e2838407f30b3be8ebf84\",\"license\":\"AGPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610622806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806306fdde03146100515780632c54e4fd1461009c57806344eea1e0146100af5780635a3efa66146100c2575b600080fd5b60408051808201909152601181527f54686520426c656570204d616368696e6500000000000000000000000000000060208201525b60405161009391906103f1565b60405180910390f35b6100866100aa36600461043a565b6100d5565b6100866100bd3660046104fe565b6100fa565b6100866100d036600461043a565b61011b565b606060006100e283610173565b90506100f285858584602c610256565b949350505050565b6060813b600061010982610173565b9050816000604c8301863c9392505050565b606060008267ffffffffffffffff8111156101385761013861040b565b6040519080825280601f01601f191660200182016040528015610162576020820181803683370190505b5090506100f2858585846000610256565b606081602c0167ffffffffffffffff8111156101915761019161040b565b6040519080825280601f01601f1916602001820160405280156101bb576020820181803683370190505b5090507f524946460000000057415645666d74201000000001000100401f0000401f000060208201527f010008006461746100000000000000000000000000000000000000000000000060408201526024820160ff8116602483015360ff8160081c16602583015360ff8160101c1660268301535060ff8216604882015360ff8260081c16604982015360ff8260101c16604a820153919050565b6000610261866102c6565b905060006040518560801b8760801b60801c17815285602085018601602083865afa915050806102bd576040517fdae8c31100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505050505050565b600080826040516020016102da9190610534565b60408051601f198184030181529190528351909150603c810161ffff81111561032f576040517f90860d6000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060081c602184015360ff811660228401538251602084016000f0935073ffffffffffffffffffffffffffffffffffffffff8416610399576040517fd4cefffb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050919050565b60005b838110156103bc5781810151838201526020016103a4565b50506000910152565b600081518084526103dd8160208601602086016103a1565b601f01601f19169290920160200192915050565b60208152600061040460208301846103c5565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060006060848603121561044f57600080fd5b833567ffffffffffffffff8082111561046757600080fd5b818601915086601f83011261047b57600080fd5b81358181111561048d5761048d61040b565b604051601f8201601f19908116603f011681019083821181831017156104b5576104b561040b565b816040528281528960208487010111156104ce57600080fd5b82602086016020830137600060208483010152809750505050505060208401359150604084013590509250925092565b60006020828403121561051057600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461040457600080fd5b7f61006d600081600b8239f36000358060801b60801c806000529060801c60205281527f5b000000000000000000000000000000000000000000000000000000000000006020820152600082516105928160218501602087016103a1565b7f6040519060ff168160600153600101806040526000518101906020511160155760219390910192830152507f6020516060f30000000000000000000000000000000000000000000000000000604182015260470191905056fea26469706673582212201be939de39f141e84938d609b7267cbcd8c42917ecbba90328dd12e23408c9af64736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806306fdde03146100515780632c54e4fd1461009c57806344eea1e0146100af5780635a3efa66146100c2575b600080fd5b60408051808201909152601181527f54686520426c656570204d616368696e6500000000000000000000000000000060208201525b60405161009391906103f1565b60405180910390f35b6100866100aa36600461043a565b6100d5565b6100866100bd3660046104fe565b6100fa565b6100866100d036600461043a565b61011b565b606060006100e283610173565b90506100f285858584602c610256565b949350505050565b6060813b600061010982610173565b9050816000604c8301863c9392505050565b606060008267ffffffffffffffff8111156101385761013861040b565b6040519080825280601f01601f191660200182016040528015610162576020820181803683370190505b5090506100f2858585846000610256565b606081602c0167ffffffffffffffff8111156101915761019161040b565b6040519080825280601f01601f1916602001820160405280156101bb576020820181803683370190505b5090507f524946460000000057415645666d74201000000001000100401f0000401f000060208201527f010008006461746100000000000000000000000000000000000000000000000060408201526024820160ff8116602483015360ff8160081c16602583015360ff8160101c1660268301535060ff8216604882015360ff8260081c16604982015360ff8260101c16604a820153919050565b6000610261866102c6565b905060006040518560801b8760801b60801c17815285602085018601602083865afa915050806102bd576040517fdae8c31100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505050505050565b600080826040516020016102da9190610534565b60408051601f198184030181529190528351909150603c810161ffff81111561032f576040517f90860d6000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060081c602184015360ff811660228401538251602084016000f0935073ffffffffffffffffffffffffffffffffffffffff8416610399576040517fd4cefffb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050919050565b60005b838110156103bc5781810151838201526020016103a4565b50506000910152565b600081518084526103dd8160208601602086016103a1565b601f01601f19169290920160200192915050565b60208152600061040460208301846103c5565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060006060848603121561044f57600080fd5b833567ffffffffffffffff8082111561046757600080fd5b818601915086601f83011261047b57600080fd5b81358181111561048d5761048d61040b565b604051601f8201601f19908116603f011681019083821181831017156104b5576104b561040b565b816040528281528960208487010111156104ce57600080fd5b82602086016020830137600060208483010152809750505050505060208401359150604084013590509250925092565b60006020828403121561051057600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461040457600080fd5b7f61006d600081600b8239f36000358060801b60801c806000529060801c60205281527f5b000000000000000000000000000000000000000000000000000000000000006020820152600082516105928160218501602087016103a1565b7f6040519060ff168160600153600101806040526000518101906020511160155760219390910192830152507f6020516060f30000000000000000000000000000000000000000000000000000604182015260470191905056fea26469706673582212201be939de39f141e84938d609b7267cbcd8c42917ecbba90328dd12e23408c9af64736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "WAV(bytes,uint256,uint256)": {
        "params": {
          "length": "the number of samples to generate.",
          "musicBytecode": "the EVM bytecode that the Bleep Machine will execute in a loop.",
          "start": "sample offset at which the music starts."
        },
        "returns": {
          "_0": "WAV file (8 bits, 8000Hz, mono)."
        }
      },
      "generate(bytes,uint256,uint256)": {
        "params": {
          "length": "the number of samples to generate.",
          "musicBytecode": "the EVM bytecode that the Bleep Machine will execute in a loop.",
          "start": "sample offset at which the music starts."
        },
        "returns": {
          "_0": "8 bits samples buffer."
        }
      },
      "listenTo(address)": {
        "params": {
          "addr": "address of any contract. Most will generate noises."
        },
        "returns": {
          "_0": "WAV file (8 bits, 8000Hz, mono)."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "WAV(bytes,uint256,uint256)": {
        "notice": "Generates a WAV file (8 bits, 8000Hz, mono) by executing the EVM bytecode provided (`musicBytecode`). The time offset is the only element on the stack at each loop iteration. Such offset starts at `start` and is increased by one for each iteration. The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration. The loop is executed `length` times to generate `length` samples which compose the music generated."
      },
      "generate(bytes,uint256,uint256)": {
        "notice": "Generates raw 8 bits samples by executing the EVM bytecode provided (`musicBytecode`). The time offset is the only element on the stack at each loop iteration. Such offset starts at `start` and is increased by one for each iteration. The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration. The loop is executed `length` times to generate `length` samples which compose the music generated."
      },
      "listenTo(address)": {
        "notice": "Generates a WAV file (8 bits, 8000Hz, mono) from contract's code at a specific address."
      },
      "name()": {
        "notice": "return the name of the contract"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}