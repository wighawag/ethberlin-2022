{
  "language": "Solidity",
  "sources": {
    "src/TheBleepMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"base64-sol/base64.sol\";\n\nerror MusicByteCodeTooLarge();\nerror MusicContractCreationFailure();\nerror MusicExecutionFailure();\n\ncontract TheBleepMachine{\n\n\tfunction play(\n\t\tbytes memory musicBytecode,\n\t\tuint256 start,\n\t\tuint256 length\n\t) external returns (string memory) {\n\t\tbytes\n\t\t\tmemory dynHeader = hex\"524946460000000057415645666d74201000000001000100401f0000401f0000010008006461746100000000\";\n\t\tassembly {\n\t\t\tlet t := add(length, 36)\n\t\t\tmstore8(add(dynHeader, 36), and(t, 0xFF))\n\t\t\tmstore8(add(dynHeader, 37), and(shr(8, t), 0xFF))\n\t\t\tmstore8(add(dynHeader, 38), and(shr(16, t), 0xFF))\n\n\t\t\tmstore8(add(dynHeader, 72), and(length, 0xFF))\n\t\t\tmstore8(add(dynHeader, 73), and(shr(8, length), 0xFF))\n\t\t\tmstore8(add(dynHeader, 74), and(shr(16, length), 0xFF))\n\t\t}\n\n\t\treturn\n\t\t\tstring(\n\t\t\t\tbytes.concat(\n\t\t\t\t\t\"data:audio/wav;base64,\",\n\t\t\t\t\tbytes(Base64.encode(bytes.concat(dynHeader, _execute(musicBytecode, start, length))))\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\tfunction _execute(\n\t\tbytes memory musicBytecode,\n\t\tuint256 start,\n\t\tuint256 length\n\t) internal returns (bytes memory) {\n\t\tbytes memory executorCreation = bytes.concat(\n            hex\"61006d600081600b8239f36000358060801b806000529060801c60205260006040525b\",\n\t\t\tmusicBytecode,\n\t\t\thex\"60ff9016604051806080019091905360010180604052602051600051600101806000529110601757602051806060526020016060f3\"\n\t\t);\n        uint256 len = musicBytecode.length;\n\n\n        uint256 codeLen;\n        unchecked {\n            codeLen = 0x4d + len;\n        }\n        if( codeLen > 0xFFFF) {\n            revert MusicByteCodeTooLarge();\n        }\n        assembly {\n            mstore8(add(executorCreation, 33), shr(8, codeLen))\n\t\t\tmstore8(add(executorCreation, 34), and(codeLen, 0xFF))\n\t\t}\n\n\t\taddress executor;\n\t\tassembly {\n\t\t\texecutor := create(0, add(executorCreation, 32), mload(executorCreation))\n\t\t}\n\n\t\tif(executor == address(0)) {\n            revert MusicContractCreationFailure();\n        }\n\n\t\t(bool success, bytes memory buffer) = executor.staticcall(abi.encode(start | (length << 128)));\n\t\tif (!success) {\n            revert MusicExecutionFailure();\n        }\n\n\t\treturn buffer;\n\t}\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}